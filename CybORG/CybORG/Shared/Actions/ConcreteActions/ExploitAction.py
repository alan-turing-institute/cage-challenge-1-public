from ipaddress import IPv4Address
from random import random

from CybORG.Shared import Observation
from CybORG.Shared.Actions.ConcreteActions.ConcreteAction import ConcreteAction
from CybORG.Shared.Actions.MSFActionsFolder.MSFAction import lo
from CybORG.Shared.Enums import ProcessType, OperatingSystemType
from CybORG.Simulator.Host import Host
from CybORG.Simulator.Process import Process
from CybORG.Simulator.Session import Session
from CybORG.Simulator.State import State


class ExploitAction(ConcreteAction):
    def __init__(self, session: int, agent: str, ip_address: IPv4Address, target_session: int):
        super().__init__(session, agent)
        self.ip_address = ip_address
        self.target_session = target_session
        self.detection_rate = 0.95

    def sim_exploit(self, state: State, port: int, process_type: str) -> Observation:
        self.state = state
        obs = Observation()
        if self.session not in state.sessions[self.agent]:
            obs.set_success(False)
            return obs
        session = state.sessions[self.agent][self.session]
        from_host = state.hosts[session.host]

        if not session.active:
            obs.set_success(False)
            return obs

        # determine which ports can communicate between which subnets
        originating_ip_address = None
        if self.ip_address == lo:
            target_host: Host = from_host
            originating_ip_address = self.ip_address
        else:
            target_host: Host = state.hosts[state.ip_addresses[self.ip_address]]
            ports = self.check_routable(
                [state.subnets[i.subnet] for i in from_host.interfaces if i.ip_address != lo],
                [s for s in state.subnets.values() if self.ip_address in s.cidr])
            if ports is None or (port not in ports and 'all' not in ports):
                obs.set_success(False)
                return obs
            from_subnet, to_subnet = ports[port] if port in ports else ports['all']
            # calculate the originating ip address
            for i in from_host.interfaces:
                if i.ip_address != lo:
                    if i.subnet == from_subnet:
                        originating_ip_address = i.ip_address

        # find out if smb is open
        vuln_proc = None
        for proc in target_host.processes:
            if proc.process_type == ProcessType.parse_string(process_type):
                for conn in proc.connections:
                    if 'local_port' in conn and conn['local_port'] == port:
                        vuln_proc = proc
                        target_host.events['NetworkConnections'].append({'local_address': self.ip_address,
                                                                         'local_port': conn["local_port"],
                                                                         'remote_address': originating_ip_address,
                                                                         'remote_port': target_host.get_ephemeral_port()})
                        break
                if vuln_proc is not None:
                    break

        if vuln_proc is None:
            obs.set_success(False)
            return obs

        if self.test_exploit_works(target_host, vuln_proc):
            obs = self.add_reverse_session(state, vuln_proc.user, originating_ip_address, target_host, session)

        else:
            obs.add_interface_info(ip_address=str(self.ip_address))

            obs.set_success(False)
        obs.add_process(hostid=str(self.ip_address), local_address=self.ip_address, local_port=port, status="open",
                        process_type=process_type)
        return obs

    def test_exploit_works(self, target_host: Host, vuln_proc: Process):
        # check if OS and process information is correct for exploit to work
        raise NotImplementedError

    def add_reverse_session(self, state: State, username: str, from_ip_address: IPv4Address, target_host: Host,
                            session: Session):
        if target_host.os_type == OperatingSystemType.WINDOWS:
            ext = 'exe'
            path = 'C:\\temp\\'
        elif target_host.os_type == OperatingSystemType.LINUX:
            ext = 'sh'
            path = '/tmp/'
        else:
            return Observation(False)
        obs = Observation()


        local_port = target_host.get_ephemeral_port()
        new_connection = {"local_port": local_port,
                          "Application Protocol": "tcp",
                          "remote_address": from_ip_address,
                          "remote_port": 4444,
                          "local_address": self.ip_address
                          }

        file = target_host.add_file(f'cmd.{ext}', path, username, 7, density=0.9, signed=False)
        proc = target_host.add_process(name=file.name, ppid=1, path=file.path, user=username)
        proc.connections.append(new_connection)
        new_session = state.add_session(host=target_host.hostname, agent=self.agent,
                                        user=username, session_type="red_reverse_shell", parent=self.session, process=proc.pid)
        if random() < self.detection_rate:
            target_host.events['NetworkConnections'].append({'local_address': self.ip_address,
                                                             'local_port': local_port,
                                                             'remote_address': from_ip_address,
                                                             'remote_port': 4444,
                                                             'pid': proc.pid})
        remote_port = {"local_port": 4444,
                       "Application Protocol": "tcp",
                       "local_address": from_ip_address,
                       "remote_address": self.ip_address,
                       "remote_port": local_port
                       }

        state.hosts[session.host].get_process(session.pid).connections.append(remote_port)
        obs.add_process(hostid=str(from_ip_address),
                        local_address=from_ip_address,
                        remote_address=str(self.ip_address),
                        local_port=4444,
                        remote_port=local_port,
                        process_type='reverse_session_handler')
        obs.add_process(hostid=str(self.ip_address),
                        local_address=str(self.ip_address),
                        remote_address=from_ip_address,
                        local_port=local_port,
                        remote_port=4444,
                        process_type='reverse_session')
        obs.add_session_info(hostid=str(self.ip_address),
                             session_id=new_session.ident,
                             session_type=new_session.session_type,
                             agent=self.agent)
        obs.add_system_info(hostid=str(self.ip_address), hostname=target_host.hostname, os_type=target_host.os_type)
        obs.set_success(True)
        return obs
